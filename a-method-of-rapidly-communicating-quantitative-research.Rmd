---
title: "A method of rapidly communicating quantitative research"
author: "Daigo Tanaka"
date: "November 23, 2014"
output:
    html_document:
        toc: true
        keep_md: true
---

## A method of rapidly communicating quantitative research

**Gist:** This article is written with [R Markdown](http://rmarkdown.rstudio.com/)
only, and the numbers and figures are dynamically generated with the data
retrieved from a PostgreSQL database or datasets package of R. I demonstrate
how the page renders, and describe how I set up the Heroku app.

*Keywords: R, rpy2, PostgreSQL, Heroku, Python, Django, R markdown, Rmd, knitr*

### 1. Introduction

Many quantitative researchers know R and R Markdown, but if one wants to
publish on web, she has to first convert Rmd to HTML and figures, and copy all
the files to the web server. This has to be repeated whenever she makes
modifications to the manuscript, R scripts, or data. The cumbersome process can
be very disruptive to her thought process of the analysis.

This web site is backed by
[a Django based application I wrote](https://github.com/daigotanaka/kawaraban),
and it converts markdown documents into HTML already. So, I thought of
extending it to accept Rmd files. To demonstrate, this page is written in Rmd
only, and the R scripts are executed on the server to produce the web page
dynamically. It also connects to PostgreSQL databases, retrieves and analyzes
data as instructed by the R scripts in the Rmd, and publishes the result.

There is [Shiny](http://shiny.rstudio.com) that produces dynamic data contents
only with the knowledge of R. However, their focus is more on developing
interactive web applications than generating research reports. RPubs is suited
for static document, but it has to be published on rpubs.com.

With the proposed system, quantitative researchers can focus on writing
manuscript and the method of analysis in markdown and R. Without having to 
switch the tool to other applications or computer languages (HTML, JavaScript,
and etc), they can post the result for others to review on proprietary
web sites both privately and publicly.

I will first demonstrate how the page is rendered from Rmd, and describe the
steps I took to make the server run R that connects to PostgreSQL database.  

### 2. Demonstration

```{r, echo=FALSE}
library(datasets)
oj05 = subset(ToothGrowth$len, ToothGrowth$supp=="OJ" & ToothGrowth$dose==0.5)
oj10 = subset(ToothGrowth$len, ToothGrowth$supp=="OJ" & ToothGrowth$dose==1.0)
oj20 = subset(ToothGrowth$len, ToothGrowth$supp=="OJ" & ToothGrowth$dose==2.0)
vc05 = subset(ToothGrowth$len, ToothGrowth$supp=="VC" & ToothGrowth$dose==0.5)
vc10 = subset(ToothGrowth$len, ToothGrowth$supp=="VC" & ToothGrowth$dose==1.0)
vc20 = subset(ToothGrowth$len, ToothGrowth$supp=="VC" & ToothGrowth$dose==2.0)

library(ggplot2)
plot.tooth.growth = ggplot(ToothGrowth, aes(x=dose, y=len, color=supp, shape=supp)) +
  geom_point() +
  scale_colour_hue(l=50) +
  geom_smooth(method=loess) +
  xlab("Dose (mg)") + ylab("Length (mm)")
```

### Example 1. From datasets

The numbers in the table and the graph are generated by running R using
ToothGrowth dataset, and they are not hard-coded on the document:

The table below is the statistical summary of ToothGrowth data in datasets
package in R (mean +/- 1 standard deviation): 

| Supplement | 0.5 mg | 1.0 mg | 2.0 mg|
| :--------- | -----: | -----: | ----: |
| Orange juice | `r round(mean(oj05), 2)` mm +/- `r round(sd(oj05), 2)` | `r round(mean(oj10), 2)` mm +/- `r round(sd(oj10), 2)` | `r round(mean(oj20), 2)` mm +/- `r round(sd(oj20), 2)` |
| Ascorbic acid | `r round(mean(vc05), 2)` mm +/- `r round(sd(vc05), 2)` | `r round(mean(vc10), 2)` mm +/- `r round(sd(vc10), 2)` | `r round(mean(vc20), 2)` mm +/- `r round(sd(vc20), 2)`0 |

Here is a 2D plot of the data from the two groups.

```{r, echo=FALSE, warning=FALSE}
plot.tooth.growth
```

Rmd source:

<script src="http://gist-it.appspot.com/https://github.com/daigotanaka/papers/blob/master/a-method-of-rapidly-communicating-quantitative-research.Rmd?slice=49:84&footer=0">
</script>

It can run hypothesis tests on the server too:

```{r}
t.test(oj05, vc05, paired=FALSE, var.equal=FALSE, conf.level=0.95)
```

#### Example 2. Connect R to PostgreSQL

This graph is generated from the data retrieved from PostgreSQL database:

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
library("RPostgreSQL")
drv = dbDriver("PostgreSQL")
con = dbConnect(drv, host="%(postgres_host)s", dbname="%(postgres_dbname)s", port="%(postgres_port)s", user="%(postgres_user)s", password="%(postgres_password)s")
rs = dbSendQuery(con, "select created_at from core_page")
pages = fetch(rs, n=-1)
t = unclass(as.POSIXlt(pages$created_at))
df = data.frame(t$hour)
library(ggplot2)
ggplot(df, aes(x=t.hour)) +
  geom_histogram(binwidth=1, colour="#C6808C", fill="#C6808C") +
  xlab("Time of the day") +
  ggtitle("Blog post time stamps")
ret = dbDisconnect(con)
```

Rmd source:

<script src="http://gist-it.appspot.com/https://github.com/daigotanaka/papers/blob/master/a-method-of-rapidly-communicating-quantitative-research.Rmd?slice=100:115&footer=0">
</script>

#### Example 3. Interactive chart with rCharts

The interactive chart below is created by less than 10 lines of R code.

Eye color counts grouped by hair colors:
```{r, echo=FALSE, message=FALSE, comment=NA, results="asis", tidy=FALSE}
library(rCharts)
hair_eye = subset(as.data.frame(HairEyeColor))
n1 <- nPlot(Freq ~ Hair, group = "Eye",
  data = hair_eye, type = "multiBarChart"
  )
n1$xAxis(axisLabel = "Hair colors")
n1$yAxis(axisLabel = "Eye color count")
n1$set(width = 600)
n1$show("inline", include_assets = TRUE, cdn = TRUE)
```

Rmd source:

<script src="http://gist-it.appspot.com/https://github.com/daigotanaka/papers/blob/master/a-method-of-rapidly-communicating-quantitative-research.Rmd?slice=126:137&footer=0">
</script>

### How to make the server run R

#### 1. Set environmental variables

* If you previously did config:set PATH or LD_LIBRARY_PATH, you should check the 
current values, and make sure you don't lose anything by doing the following:

```
$ heroku config:set PATH=/app/vendor/pg/bin:/app/vendor/R/bin:/app/vendor/gcc-4.3/bin:/app/.heroku/python/bin:/usr/local/bin:/usr/bin:/bin
$ heroku config:set LD_LIBRARY_PATH=/app/.heroku/vendor/lib:/app/.heroku/python/lib::/app/vendor/R/lib64/R/modules:/app/vendor/R/lib64/R/lib:/app/vendor/gcc-4.3/lib64:/app/vendor/pg/lib
```

#### 2. Create .buildpacks file

Add .buildpacks to the root of the Heroku app repository, and add these lines
in the order:

```
https://github.com/daigotanaka/heroku-postgres-client-buildpack.git
https://github.com/virtualstaticvoid/heroku-buildpack-r.git
https://github.com/daigotanaka/heroku-buildpack-python.git
```

#### 3. Add rpy2 to requirements.txt

Add rpy2 ver. 2.3.10 to requirements.txt:

```
rpy2==2.3.10
```

Note: Previous version of rpy would have an installation problem.

#### 4. Create init.r

Add R packages in init.r to the root of the Heroku app repository, and add pages to be installed:

```
install.packages("datasets", dependencies = TRUE)
install.packages("methods", dependencies = TRUE)
install.packages("ggplot2", dependencies = TRUE)
install.packages("knitr", dependencies = TRUE)
install.packages("RPostgreSQL", dependencies = TRUE)
```

#### 5. Commit changes and push

* This is assuming that you are adding to an existing app.

```
$ git add .
$ git commit -m "Build R and Python, and instal rpy2"
$ heroku config:set BUILDPACK_URL=https://github.com/ddollar/heroku-buildpack-multi.git 
$ git push heroku master
```

Build takes about 10 minutes.

#### 6. Verify installation

```
$ heroku login
$ heorku run bash --app your-app-name
# Below is in bash on heroku app instance
$ python 
>> from rpy2 import robjects
>> robjects.r("library(datasets); ToothGrowth")
```

### rpy knit2html example 

As in [gist](https://gist.github.com/daigotanaka/0975ef6b34b6405a284a):

<script src="https://gist.github.com/daigotanaka/0975ef6b34b6405a284a.js"></script>

## Word of caution

1. One should always cache the knit2html conversion result as the process could
be costly to the server load. It is also recommended to deligate this task to
a worker instance.
1. The Heroku buildpacks for
[PostgreSQL client](https://github.com/daigotanaka/heroku-postgres-client-buildpack.git)
and
[Python](https://github.com/daigotanaka/heroku-buildpack-python.git)
were created or modified by me, and I don't guarantee it works, nor do I promise any future
support.
1. In creating a public service like this, the ability to embed a PostgreSQL code could be a big security risk. Such service needs a robust filter to reject malicious scripts from slipping into the manuscript.

Please give feedback to this article by commenting directly on the source in the
[repository](https://github.com/daigotanaka/papers/pull/1/files?diff=unified)
